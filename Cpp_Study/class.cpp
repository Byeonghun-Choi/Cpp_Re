//  클래스
//  : 서로 관련 있는 변수 and 함수들을 한 곳으로 모은 것

//  필드
//  : 클래스 안에 선언되는 변수(멤버변수라고도 부른다.)


// 클래스의 사용을 예로 들기 가장 적절한 예시다
//--------------------------------------------------------
/*
#include<iostream>
#include<string>
using namespace std;

class Car {
public:
    int speed;    // 속도
    int gear;     // 기어
    string color; // 색상

    // 멤버함수 선언
    void speedUp() {
        speed += 10;
    }

    void speedDown() {
        speed -= 10;
    }
};

int main() 
{
    Car myCar;  // 객체의 생성

    // 멤버변수의 접근
    myCar.speed = 100;
    myCar.gear = 3;
    myCar.color = 'red';

    // 멤버함수 호출
    myCar.speedUp();
    myCar.speedDown();

    return 0;
}
*/
//----------------------------------------------------
// 다음은 두가지 객체를 사용했을 때, 예시 코드이다.

#include<iostream>
#include<string>
using namespace std;

class Car {
public:
    int speed;    // 속도
    int gear;     // 기어
    string color; // 색상

    // 멤버함수 선언
    void speedUp() {
        speed += 10;
    }

    void speedDown() {
        speed -= 10;
    }

    void show()
    {
        cout << "==================" << endl;
        cout << "속도 : " << speed << endl; 
        cout << "기어 : " << gear << endl;
        cout << "색상 : " << colot << endl;
        cout << "==================" << endl;
    }
};

int main() 
{
    Car myCar, yourCar;  // 객체의 생성

    // 멤버변수의 접근
    myCar.speed = 100;
    myCar.gear = 3;
    myCar.color = 'red';

    // 두번째 객체의 변수 설정
    yourCar.speed = 10;
    yourCar.gear = 1;
    yourCar.color = "blue";

    // 멤버함수 호출
    myCar.speedUp();
    yourCar.speedUp();
    myCar.show();
    yourCar.show();

    return 0;
}
//----------------------------------------------------------------------
// 간접참조 연산자 * 
// : 포인터의 사용은 메모리 사용을 줄이기 위해서라는 것을 잊지말자
//   포인터가 가리키는 위치의 값을 읽는 것
// Ex
/*
int i = 10;
int* p = &i;
cout << *p; // 10
*/
//---------------------------------------------------------------------------------------------------------------
// 포인터 사용 시 주의점
// 1) 포인터는 반드시 선언시 초기화를 해주어야 한다. 그렇지 않으면 임의의 주소값을 가리킨다. 이는 굉장히 위험한 행동이다
// 2) 따라서 포인터를 선언 후 값을 두기 애매할 경우 NULL; 로 지정해주는 것이 좋다. 
//    이렇듯 NULL로 지정해 줄 경우 잘못 접근하였을때 프로그램 오류를 내며 종료시켜준다

// 이 외에도 지식을 탄탄히 해주는 중간점검 문제가 있어서 적어본다
/*
1. 포인터도 변수인가?
A : 맞다. 포인터는 다른 변수의 주소를 참조하는 변수이다.
2. 변수의 주소를 추출하는데 사용되는 연산자는 무엇인가?
A : 간접참조 연산자인 * 이다.
3. 변수 x의 주소를 추출하여 변수 p에 대입하는 문장을 써보아라.
A : 이 부분은 코드로 적어보자면
int x = NULL;
int *p = &i; 
라고 나타낼 수 있겠다.
4. 정수형 포인터 p가 가리키는 위치에 25를 저장하는 문장을 써보아라.
A : 
int i = 25;
p = &i;
5. 포인터에 대하여 적용할 수 있는 연산에는 어떤 것들이 있는가?
A : ++, -- 등이 있다. 참고로 char 형에 대해서는 값의 증감이 불가능하다.
6. int 형 포인터 p가 80번지를 가리키고 있었다면 (p+1)은 몇 번지를 가리키는가?
A : 84 (int 형은 4byte)
7. p가 포인터라고 하면 *p++ 와 (*p)++의 차이점은 무엇인가?
A : 간접참조 연산자 * 보다 증감연산자인 ++의 우선순위가 높으므로 *p++는 가리키는 주소가 증가한 후 주소를 참조하고, (*p)++ 는 주소를 가리키고 연산을 진행한다.
8. p가 포인터라고 하면 *(p+3) 의 의미는 무엇인가?
A : (p+3)의 주소를 가리킨다.
*/

// 포인터는 배열과 아주 밀접한 관계를 갖고 있다.
// 포인터는 주소를 가리키는데, 배열은 그 자체가 하나의 주소이다. 그래서 배열 이름은 첫번째 배열원소의 주소와 같다.
// 다음은 포인터를 이용하여 배열의 전체 원소를 출력하는 프로그램이다.
//------------------------------------------------------------------------------------------------------------
#include<iostream>
using namespace std;

int main(void)
{
    const int STUDENTS = 5;
    int grade[STUDENTS] = { 10, 20, 30, 40, 50 };

    for (int *p = grade, *pend = grade + STUDENTS; p != pend; p++) // grade, 배열 이름은 첫 번째 패열 원소를 가리키는 포인터다. grade + STUDENTS는 배열을 벗어난 위치이다.
        cout << *p << " ";
    
    return 0;
}
//---------------------------------------------------------------------------------------------------------------
/* 
const는 상수를 만드는 수식어이다. 임의로 변경이 불가능하며, 접근조차도 불가능하다.
double* const p; // double 타입의 객체를 가리키는 상수 포인터 p
*/
//----------------------------------------------------------------------------------------------------------------
/*
void 포인터 
: C 에서는 실제로 void를 자주 사용했었다. int main(void) 라던지 void main 이라던지 
  C++ 에서도 void 포인터가 존재하는데, 이는 아무것도 가리키지 않는 포인터다. 잠재적으로 문제가 될 수 있으니, 사용을 자제하는 것이 좋겠다.
*/
//------------------------------------------------------------------------------------------------------------------

// C에서 malloc 과 free 를 사용했던 경험이 있을 것이다. 이는 동적메모리를 사용할만큼 빌려왔다가 나중에 다시 돌려주는 식인데, 상당히 번거롭다. 
// C++ 에서는 new 와 delete 라는 전용 함수가 있다. 물론 C++은 C 를 포홤할 수 있기에 malloc과 free를 사용하는 것이 문제되지는 않는다.
// 말로 100번 하는 것보다 한번 보여주는 것이 낫다고 생각하기에 이와 같이 코드를 첨부하겠다.
//--------------------------------
#include<iostream>
using namespace std;

int main() 
{
    int *pi;            // 동적 메모리를 가리키는 포인터
    pi = new int[100];  // 크기가 100 인 동적 배열 생성

    for (int i = 0; i < 100; i++)
        *(pi+i) = 0;    // 동적 메모리 사용
    delete[] pi;        // 동적 메모리 반납

    return 0;
}
//----------------------------------
// 동적메모리의 할당과 반납이 와닿지 않아서 반복적으로 사용하는 예시를 들어보겠다.
//-----------------------------------
int *pi = new int; // 하나의 int형 공간 할당
delete pi;         // 동적 할당 int형 공간 반납

int *pia = new int[100]; // 크기가 100인 int형 동적배열 할당
delete[] pia;            // 동적 할당 배열 반납

double *pd = new double; // 하나의 double형 공간 할당
delete pd;               // 동적할당 double형 공간 반납

double *pda = new double[100]; // 크기가 100인 double형 동적 배열 할당
delete[] pda;                  // 동적 할당 배열 반납
//---------------------------------------

// * 참조자 
// : 변수의 다른이름, 즉 별명이다. 
int var = 10;
int &ref = var;  // 이러면 var의 별명인 ref 라는 참조자가 생긴 것이다.

// 참고로 var 의 값을 변형시켜도 ref 의 값이 변하고, ref 의 값을 변경시켜도 var의 값이 변경된다. (운명공동체 라고도 할수있다.)
// 참조자는 선언과 동시에 초기화시켜야한다. 그렇지 않으면 컴파일 오류가 발생한다.
// 즉 선 선언, 후 초기화 가 불가능 하다는 것이다.
// 참조자는 포인터와 비슷해보이지만, 포인터는 변수이기 때문에, 포인터가 가리키는 대상은 얼마든지 변경될 수가 있다. 
// but 참조자는 자신만의 공간메모리가 할당되지 않기 때문에, 가리키는 대상을 변경할 수 없다는 것이 차이다.
// 그래서 참조자를 어디에 쓰는데???
// 참조자는 상수포인터와 가장 유사하다(const) 주로 함수 호출 시에 매개 변수와 반환 값으로 사용된다.
//---------------------------------------------
void dec_by_r(int &r) { // r 은 time의 참조자이다.
    r--;                // time 이 감소된다.
    return;
}

void dec_by_p(int* p) {
    --(*p);             // tume 이 감소된다.
    return;
}

int main() 
{
    int time = 10;

    dec_by_r(time);    // time 을 전달한다.
    dec_by_p(&time);   // time 의 주소를 전달한다.

    return 0;
}
//----------------------------------------------------
// 참고 
// : 포인터는 NULL 포인터가 존재한다. 하지만 참조자의 경우 선언과 동시에 초기화를 해야하기 때문에 NULL 이 존재할 수가 없다.




